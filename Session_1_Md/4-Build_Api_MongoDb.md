# Configure MongoDB

If using Windows, MongoDB is installed at C:\Program Files\MongoDB by default.

 Add C:\Program Files\MongoDB\Server\<version_number>\bin to the Path environment variable. This change enables MongoDB access from anywhere on your development machine.


Use the mongo Shell in the following steps to create a database, make collections, and store documents. For more information on mongo Shell commands, see Working with the mongo Shell.


1. Choose a directory on your development machine for storing the data. For example, C:\ReservationData on Windows. Create the directory if it doesn't exist. The mongo Shell doesn't create new directories.

2. Open a command shell. Run the following command to connect to MongoDB on default port 27017. Remember to replace <data_directory_path> with the directory you chose in the previous step.

       mongod --dbpath <data_directory_path>
3. Open another command shell instance. Connect to the default test database by running the following command:

        mongo 
    
4. Run the following in a command shell:

       use ReservationtoreDb
       
    If it doesn't already exist, a database named ReservationtoreDb is created. If the database does exist, its connection is opened for transactions.


5. Create a Reservation collection using following command:

        db.createCollection('Reservation')

The following result is displayed:

        { "ok" : 1 }
6. Define a schema for the Reservation collection and insert two documents using the following command:

console

Copy
db.Reservation.insertMany([{'RoomId':'rmconf1234','Price':1540.93,'Category':'Computers','ReservationName':'Ralph Johnson'}, {'RoomId':'rmking1234','Price':143.15,'Category':'Computers','ReservationName':'Robert C. Martin'}])
7. The following result is displayed:

    {
         "acknowledged" : true,
        "insertedIds" : [
          ObjectId("5bfd996f7b8e48dc15ff215d"),
          ObjectId("5bfd996f7b8e48dc15ff215e")
        ]
    }
> Note
>The ID's shown in this article will not match the IDs when you run this sample.

7. View the documents in the database using the following command:

        db.Reservation.find({}).pretty()
        
The following result is displayed:

        {
            "_id" : ObjectId("5bfd996f7b8e48dc15ff215d"),
            "Name" : "Design Patterns",
            "Price" : 54.93,
            "Category" : "Computers",
            "Author" : "Ralph Johnson"
        }
        {
             "_id" : ObjectId("5bfd996f7b8e48dc15ff215e"),
            "Name" : "Clean Code",
             "Price" : 43.15,
            "Category" : "Computers",
             "Author" : "Robert C. Martin"
        }



The schema adds an autogenerated _id property of type ObjectId for each document.

The database is ready. You can start creating the ASP.NET Core web API.

# Create the ASP.NET Core web API project

* Visual Studio
* Visual Studio Code
* Visual Studio for Mac
1. Go to File > New > Project.

2. Select the ASP.NET Core Web Application project type, and select Next.

3. Name the project ReservationApi, and select Create.

4. Select the .NET Core target framework and ASP.NET Core 3.0. Select the API project template, and select Create.

5. Visit the [NuGet Gallery: MongoDB.Driver](https://www.nuget.org/packages/MongoDB.Driver/) to determine the latest stable version of the .NET driver for MongoDB. In the Package Manager Console window, navigate to the project root. Run the following command to install the .NET driver for MongoDB:

PowerShell  |   Copy
------------|------------
Install-Package MongoDB.Driver -Version {VERSION} |
## Add an entity model 
1. Add a Models directory to the project root. |

2. Add a reservation class to the Models directory with the following code:

C#  | Copy
----|-----

    using MongoDB.Bson; 
    using MongoDB.Bson.Serialization.Attributes;

    namespace ReservationApi.Models
    {
    public class reservation
        {
            [BsonId]
            [BsonRepresentation(BsonType.ObjectId)]
            public string Id { get; set; }

            [BsonElement("Name")]
            public string reservationName { get; set; }

            public decimal Price { get; set; }

            public string Category { get; set; }

            public string Author { get; set; }
       }
    }
In the preceding class, the Id property:

* Is required for mapping the Common Language Runtime (CLR) object to the MongoDB collection.

* Is annotated with [BsonId] to designate this property as the document's primary key.

* Is annotated with [BsonRepresentation(BsonType.ObjectId)] to allow passing the parameter as type string instead of an ObjectId structure. Mongo handles the conversion from string to ObjectId.

The reservationName property is annotated with the [BsonElement] attribute. The attribute's value of Name represents the property name in the MongoDB collection.


## Add a configuration model

1. Add the following database configuration values to appsettings.json:

JSON  | Copy
------|----

        {
            "ReservationtoreDatabaseSettings": {
            "ReservationCollectionName": "Reservation",
            "ConnectionString": "mongodb://localhost:27017",
            "DatabaseName": "ReservationtoreDb"
        },
            "Logging": {
            "IncludeScopes": false,
            "Debug": {
            "LogLevel": {
            "Default": "Warning"
            }
        },
    "Console": {
      "LogLevel": {
        "Default": "Warning"
        }
       }
      }
    }
2. Add a ReservationtoreDatabaseSettings.cs file to the Models directory with the following code:


C#   | Copy
------|----



        namespace ReservationApi.Models
           {
             public class ReservationtoreDatabaseSettings : IReservationtoreDatabaseSettings
             {
              public string ReservationCollectionName { get; set; }
              public string ConnectionString { get; set; }
              public string DatabaseName { get; set; }
              }

          public interface IReservationtoreDatabaseSettings
          {
           string ReservationCollectionName { get; set; }
           string ConnectionString { get; set; }
           string DatabaseName { get; set; }
            }
    }
The preceding ReservationtoreDatabaseSettings class is used to store the appsettings.json file's ReservationtoreDatabaseSettings property values. The JSON and C# property names are named identically to ease the mapping process.

3. Add the following highlighted code to Startup.ConfigureServices:

C#   | Copy
------|----

        public void ConfigureServices(IServiceCollection services)
        {
          // requires using Microsoft.Extensions.Options
         services.Configure<ReservationtoreDatabaseSettings>(
             Configuration.GetSection(nameof(ReservationtoreDatabaseSettings)));

         services.AddSingleton<IReservationtoreDatabaseSettings>(sp =>
             sp.GetRequiredService<IOptions<ReservationtoreDatabaseSettings>>().Value);

         services.AddControllers();
        }
In the preceding code:

* The configuration instance to which the appsettings.json file's ReservationtoreDatabaseSettings section binds is registered in the Dependency Injection (DI) container. For example, a ReservationtoreDatabaseSettings object's ConnectionString property is populated with the ReservationtoreDatabaseSettings:ConnectionString property in appsettings.json.

* The IReservationtoreDatabaseSettings interface is registered in DI with a singleton service lifetime. When injected, the interface instance resolves to a ReservationtoreDatabaseSettings object.
Add the following code to the top of Startup.cs to resolve the ReservationtoreDatabaseSettings and IReservationtoreDatabaseSettings references:

C#   | Copy
------|----

        using ReservationApi.Models;
## Add a CRUD operations service
1. Add a Services directory to the project root.

2. Add a ReservationService class to the Services directory with the following code:

C#   | Copy
------|----

    using ReservationApi.Models;
    using MongoDB.Driver;
    using System.Collections.Generic;
    using System.Linq;

    namespace ReservationApi.Services
    {
         public class ReservationService
    {
        private readonly IMongoCollection<reservation> _Reservation;

        public ReservationService(IReservationtoreDatabaseSettings settings)
        {
            var client = new MongoClient(settings.ConnectionString);
            var database = client.GetDatabase(settings.DatabaseName);

            _Reservation = database.GetCollection<reservation>(settings.ReservationCollectionName);
        }

        public List<reservation> Get() =>
            _Reservation.Find(reservation => true).ToList();

        public reservation Get(string id) =>
            _Reservation.Find<reservation>(reservation => reservation.Id == id).FirstOrDefault();

        public reservation Create(reservation reservation)
        {
            _Reservation.InsertOne(reservation);
            return reservation;
        }

        public void Update(string id, reservation reservationIn) =>
            _Reservation.ReplaceOne(reservation => reservation.Id == id, reservationIn);

        public void Remove(reservation reservationIn) =>
            _Reservation.DeleteOne(reservation => reservation.Id == reservationIn.Id);

        public void Remove(string id) => 
            _Reservation.DeleteOne(reservation => reservation.Id == id);
        }
    }

In the preceding code, an IReservationtoreDatabaseSettings instance is retrieved from DI via constructor injection. This technique provides access to the appsettings.json configuration values that were added in the Add a configuration model section.

3. Add the following highlighted code to Startup.ConfigureServices:

C#   | Copy
------|----
    
    public void ConfigureServices(IServiceCollection services)
    {
        services.Configure<ReservationtoreDatabaseSettings>(
        Configuration.GetSection(nameof(ReservationtoreDatabaseSettings)));

        services.AddSingleton<IReservationtoreDatabaseSettings>(sp =>
        sp.GetRequiredService<IOptions<ReservationtoreDatabaseSettings>>().Value);

        services.AddSingleton<ReservationService>();

        services.AddControllers();
    }

In the preceding code, the ReservationService class is registered with DI to support constructor injection in consuming classes. The singleton service lifetime is most appropriate because ReservationService takes a direct dependency on MongoClient. Per the official Mongo Client reuse guidelines, MongoClient should be registered in DI with a singleton service lifetime.

4. Add the following code to the top of Startup.cs to resolve the ReservationService reference:

C#   | Copy
------|----
    using ReservationApi.Services;

The ReservationService class uses the following MongoDB.Driver members to perform CRUD operations against the database:

* [MongoClient](https://api.mongodb.com/csharp/current/html/T_MongoDB_Driver_MongoClient.htm) – Reads the server instance for performing database operations. The constructor of this class is provided the MongoDB connection string:

C#   | Copy
------|----
    public ReservationService(IReservationtoreDatabaseSettings settings)
    {
           var client = new MongoClient(settings.ConnectionString); //copy this line
           var database = client.GetDatabase(settings.DatabaseName);

          _Reservation = database.GetCollection<reservation>(settings.ReservationCollectionName);
    }
[IMongoDatabase](https://api.mongodb.com/csharp/current/html/T_MongoDB_Driver_IMongoDatabase.htm) – Represents the Mongo database for performing operations. This tutorial uses the generic GetCollection<TDocument>(collection) method on the interface to gain access to data in a specific collection. Perform CRUD operations against the collection after this method is called. In the GetCollection<TDocument>(collection) method call:

collection represents the collection name.
TDocument represents the CLR object type stored in the collection.
GetCollection<TDocument>(collection) returns a MongoCollection object representing the collection. In this tutorial, the following methods are invoked on the collection:

DeleteOne – Deletes a single document matching the provided search criteria.
Find<TDocument> – Returns all documents in the collection matching the provided search criteria.
InsertOne – Inserts the provided object as a new document in the collection.
ReplaceOne – Replaces the single document matching the provided search criteria with the provided object.
Add a controller
Add a ReservationController class to the Controllers directory with the following code:

C#   | Copy
------|----
    using Microsoft.AspNetCore.Authorization;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Extensions.Configuration;
    using ReservationApi.Data.Models;
    using ReservationApi.Services;
    using Serilog;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    namespace ReservationApi.Controllers
    {


    //Session 1

    //Uses the ReservationService class to perform CRUD operations.
    //Contains action methods to support GET, POST, PUT, and DELETE HTTP requests.
    //Calls CreatedAtRoute in the Create action method to return an HTTP 201 response.Status 
    //code 201 is the standard response for an HTTP POST method that creates a new resource on 
    //the server.CreatedAtRoute also adds a Location header to the response. The Location header 
    //specifies the URI of the newly created Reservation.




    [Produces("application/json", "application/xml")]
    [Route("api/[controller]")]
    [ApiController]
    //[Authorize]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status406NotAcceptable)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public class ReservationController : ControllerBase
    {

        private readonly ReservationService _reservationService;
        private readonly IConfiguration _config;


        public ReservationController(ReservationService reservationService, IConfiguration config)
        {
            _reservationService = reservationService;
            _config = config;
        }


        /// <summary>
        /// Get all Reservations.
        /// </summary>
        /// <response code="200">Returns when the Reservation is found </response>
        /// <response code="400">If the Reservation is null</response>
        /// <response code="404">If the Reservation is Not Found</response>
        [HttpGet]
        //[Authorize]  //Session 3 Identity Server OpenID Connect OAuth Bearer Token
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<List<Reservation>>> GetAsync()
        {
            var reservations = await _reservationService.GetAsync();

            Log.Information($"In My Reservation the controller:: {reservations} {DateTime.UtcNow}!");

            return reservations;
        }


        /// <summary>
        /// Get a specific Reservation.
        /// </summary>
        /// <param name="id"></param> 
        /// <response code="200">Returns when the Reservation is found </response>
        /// <response code="400">If the Reservation is null</response>
        /// <response code="404">If the Reservation is Not Found</response>
        [HttpGet("{id}", Name = "GetReservation")]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        [ProducesResponseType(StatusCodes.Status200OK)]
        public async Task<ActionResult<Reservation>> GetAsync(string id)
        {
            var reservation = await _reservationService.GetAsync(id);

            if (reservation == null)
            {
                Log.Information($"Reservation for Id:{id} Not Found");
                return NotFound();
            }

            return Ok(reservation);
        }

        /// <summary>
        /// Create a Reservation.
        /// </summary>
        /// <remarks>
        /// Sample request:
        ///
        ///     POST /Reservation 
        ///     {
        ///        
        ///       "Name": "string",
        ///       "Price": 0,
        ///       "RoomId": "string",
        ///       "FromDate": "string",
        ///       "ToDate": "string"
        ///     }
        ///
        /// </remarks>
        /// <param name="reservation"></param>
        /// <returns>A newly created Reservation</returns>
        /// <response code="201">Returns the newly created Reservation </response>
        /// <response code="400">If the Reservation is null</response>            
        [HttpPost]
        [Consumes("application/json")]
        [ProducesResponseType(StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task<ActionResult<Reservation>> CreateAsync(Reservation reservation)
        {
            if (reservation == null)
                return BadRequest("No Reservation supplied");

            //if id is passed in with request, empty it so it can be generated by data layer
            if (!string.IsNullOrEmpty(reservation.Id))
                reservation.Id = string.Empty;

            var newReservation = await _reservationService.CreateAsync(reservation);

            return CreatedAtRoute("GetReservation", new { id = reservation.Id }, newReservation);
        }

        /// <summary>
        /// Update a specific reservation
        /// </summary>
        /// <param name="id"></param>
        /// <param name="reservationIn"></param>
        /// <response code="204">Returns when the Reservation is Succesfully Updated </response>
        /// <response code="404">If the Reservation is Not Found</response>
        [Consumes("application/json")]
        [HttpPut("{id}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task<IActionResult> UpdateAsync(string id, Reservation reservationIn)
        {
            var reservation = await _reservationService.GetAsync(id);

            if (reservation == null)
            {
                //status code 404
                return NotFound();
            }

            await _reservationService.UpdateAsync(id, reservationIn);

            return NoContent();
        }

        /// <summary>
        /// Delete a specific Reservation.
        /// </summary>
        /// <param name="id"></param> 
        /// <response code="204">Returns when the Reservation is Succesfully Deleted </response>
        /// <response code="404">If the Reservation is Not Found</response>
        [HttpDelete("{id}")]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        public async Task<IActionResult> DeleteAsync(string id)
        {
            var reservation = await _reservationService.GetAsync(id);

            if (reservation == null)
            {
                return NotFound();
            }

            await _reservationService.RemoveAsync(reservation.Id);

            return NoContent();
            }
        }
    }

The preceding web API controller:

Uses the ReservationService class to perform CRUD operations.
Contains action methods to support GET, POST, PUT, and DELETE HTTP requests.
Calls CreatedAtRoute in the Create action method to return an HTTP 201 response. Status code 201 is the standard response for an HTTP POST method that creates a new resource on the server. CreatedAtRoute also adds a Location header to the response. The Location header specifies the URI of the newly created reservation.
Test the web API
Build and run the app.

Navigate to http://localhost:<port>/api/Reservation to test the controller's parameterless Get action method. The following JSON response is displayed:

JSON  | Copy
------|----
    [
        "Name": "Lisa Love",
        "Price": 2054.93,
        "RoomId": "a123Conf",
        "FromDate": "1/12/2020",
        "ToDate": "1/20/2020",
        "Id": "5e14fa52188a05c014258026"
    },
    {
      "Name": "Bob Barker",
      "Price": 2054.93,
      "RoomId": "a123Conf",
      "FromDate": "1/13/2020",
      "ToDate": "1/17/2020",
      "Id": "5e151e81dc9288cc603af406"
     },
]
Navigate to http://localhost:<port>/api/Reservation/{id here} to test the controller's overloaded Get action method. The following JSON response is displayed:

JSON  | Copy
------|----
    {
      "Name": "Bob Barker",
      "Price": 2054.93,
      "RoomId": "a123Conf",
      "FromDate": "1/13/2020",
      "ToDate": "1/17/2020",
      "Id": "5e151e81dc9288cc603af406"
     },
## Configure JSON serialization options

There are two details to change about the JSON responses returned in the Test the web API section:
* The property names' default camel casing should be changed to match the Pascal casing of the CLR object's property names.
* The ReservationName property should be returned as Name.

To satisfy the preceding requirements, make the following changes:
1. JSON.NET has been removed from ASP.NET shared framework. Add a package reference to Microsoft.AspNetCore.Mvc.NewtonsoftJson.

2. In Startup.ConfigureServices, chain the following highlighted code on to the AddMvc method call:

C#   | Copy
------|----

    public void ConfigureServices(IServiceCollection services)
    {
    services.Configure<ReservationtoreDatabaseSettings>(
        Configuration.GetSection(nameof(ReservationtoreDatabaseSettings)));

        services.AddSingleton<IReservationtoreDatabaseSettings>(sp =>
        sp.GetRequiredService<IOptions<ReservationtoreDatabaseSettings>>().Value);

        services.AddSingleton<ReservationService>();

    services.AddControllers()
        .AddNewtonsoftJson(options => options.UseMemberCasing());
    }
With the preceding change, property names in the web API's serialized JSON response match their corresponding property names in the CLR object type. For example, the Reservation class's Author property serializes as Author.

3. In Models/Reservation.cs, annotate the ReservationName property with the following [JsonProperty] attribute:

C#   | Copy
------|----


    [BsonElement("Name")]
    [JsonProperty("Name")]
    public string ReservationName { get; set; }

The [JsonProperty] attribute's value of Name represents the property name in the web API's serialized JSON response.

4. Add the following code to the top of Models/Reservation.cs to resolve the [JsonProperty] attribute reference:

C#   | Copy
------|----
    using Newtonsoft.Json;

5. Repeat the steps defined in the Test the web API section. Notice the difference in JSON property names.

## Add authentication support to a web API

ASP.NET Core Identity adds user interface (UI) login functionality to ASP.NET Core web apps. To secure web APIs and SPAs, use one of the following:
* Azure Active Directory
* Azure Active Directory B2C (Azure AD B2C)]
* IdentityServer4

IdentityServer4 is an OpenID Connect and OAuth 2.0 framework for ASP.NET Core 3.0. IdentityServer4 enables the following security features:
* Authentication as a Service (AaaS)
* Single sign-on/off (SSO) over multiple application types
* Access control for APIs
* Federation Gateway
For more information, see Welcome to [IdentityServer4](http://docs.identityserver.io/en/latest/index.html).

## Create Repositories for Data Access

In this section, we will create a repository for encapsulating the MongoDb client functionality as well as an implementation for EF Core.  The `ReservationService` implementation will utilize these repositories for data access to mongodb data and sql data.

The repository will also implement an interface called  `IRepository<T>` that will be used directly by the service and can be used for mocking out the mongodb client or EF Core dependency during unit testing.

### Create Data project

This project will house the repository interface and the `Reservation` model class.  It is meant to be shared between other repository implementations.

* Create new .NET Core Class Library project and add the following folders.

  * **Interfaces**

  * **Models**

* Add a new class called `BaseEntity` to the Models folder and add the following implementation.

    ```cs
    using MongoDB.Bson.Serialization.Attributes;
    using MongoDB.Bson.Serialization.IdGenerators;

    namespace ReservationApi.Data.Models
    {
        public abstract class BaseEntity
        {
            [BsonId]
            [BsonRepresentation(MongoDB.Bson.BsonType.ObjectId)]
            public string Id { get; set; }
        }
    }
    ```

    >**NOTE**: This will be the base class that can be shared across other entities/models in the domain

* Add a new class called `IRepository` to the Interfaces folder and add the following implementation

    ```cs
    using ReservationApi.Data.Models;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    namespace ReservationApi.Data.Intefaces
    {
        public interface IRepository<T> where T : BaseEntity
        {
            Task DeleteAsync(T entity);
            Task DeleteAsync(string id);
            Task<T> GetAsync(string id);
            Task<List<T>> GetAsync();
            Task<T> InsertAsync(T entity);
            Task UpdateAsync(T entity);
        }
    }
    ```

* Add a new class called `Reservation` to the Models folder and add the following implementation

    ```cs
    using MongoDB.Bson.Serialization.Attributes;
    using Newtonsoft.Json;
    using System.ComponentModel.DataAnnotations;

    namespace ReservationApi.Data.Models
    {
        public class Reservation : BaseEntity
        {
            [JsonProperty("Name")]
            [BsonElement("Name")]
            [MaxLength(150)]
            public string Name { get; set; }

            public decimal Price { get; set; }
            public string RoomId { get; set; }
            public string FromDate { get; set; }
            public string ToDate { get; set; }
        }
    }
    ```

    >**NOTE**: This entity inherits from the `BaseEntity` which provides the id property

### Create MongoDb Repository project

This project will house the MongoDb Client SDK and implement the `IRepository<>` interface within the data project

* Create a new .NET Core Class Library project called `ReservationApi.Data.MongoDb` within the solution.

* Add the following nuget references to project file

    ```xml
    <ItemGroup>
        <PackageReference Include="Microsoft.Extensions.Configuration" Version="2.2.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="2.2.0" />
        <PackageReference Include="MongoDB.Driver" Version="2.10.0" />
    
    </ItemGroup>
    ```

* Create the following folder within the project

  * **Repos**

  * **DependencyInjection**

* Create a new class called `MongoRepository` within the Repos folder and add the following implementation.

  ```cs
    using MongoDB.Driver;
    using ReservationApi.Data.Intefaces;
    using ReservationApi.Data.Models;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    namespace ReservationApi.Data.MongoDb.Repos
    {
        public class MongoRepository<T> : IRepository<T> where T : BaseEntity
        {
            private readonly IMongoCollection<T> _collection;

            public MongoRepository(IMongoCollection<T> collection)
            {
                _collection = collection;
            }
            public async Task DeleteAsync(T entity)
            {
                await _collection.DeleteOneAsync(x => x.Id == entity.Id);
            }

            public async Task DeleteAsync(string id)
            {
                await _collection.DeleteOneAsync(x => x.Id == id);
            }

            public async Task<T> GetAsync(string id)
            {
                return await _collection.Find<T>(book => book.Id == id).FirstOrDefaultAsync();
            }

            public async Task<List<T>> GetAsync()
            {
                return await _collection.Find(reservation => true).ToListAsync();
            }

            public async Task<T> InsertAsync(T entity)
            {
                await _collection.InsertOneAsync(entity);
                return entity;
            }

            public async Task UpdateAsync(T entity)
            {
                await _collection.ReplaceOneAsync(book => book.Id == entity.Id, entity);
            }
        }
    }
    ```

    >**NOTE**: This is the implementation of the `IRepository<>` interface that will be used within the Service project.

* Create a new class called `ServiceCollectionExtensions` within the DependencyInjection folder and add the following implementation.

    ```cs
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.DependencyInjection.Extensions;
    using MongoDB.Driver;
    using ReservationApi.Data.Intefaces;
    using ReservationApi.Data.Models;
    using ReservationApi.Data.MongoDb.Repos;

    namespace ReservationApi.Data.MongoDb.DependencyInjection
    {
        public static class ServiceCollectionExtensions
        {
            public static void AddMongoDatabaseSupport(this IServiceCollection services, IConfiguration configuration)
            {
                services.AddScoped<IMongoCollection<Reservation>>(sp =>
                {
                    var config = configuration.GetSection("ReservationDataBaseSettings");

                    var client = new MongoClient(config["ConnectionString"]);
                    var database = client.GetDatabase(config["DatabaseName"]);

                    return database.GetCollection<Reservation>(config["ReservationCollectionName"]);
                });

                services.TryAddScoped<IRepository<Reservation>, MongoRepository<Reservation>>();
            }
        }
    }
    ```

    >**NOTE**: This is an extension method to the ServiceCollection DI container for ASP.NET Core.  The ReservationApi webapi project will use this to easily register the MongoDb Repository within DI.

* Make sure to add a reference to the `ReservationApi.Data` project in order to have access to the interface.

### Creating the EF Core repository project

This project will implement access to SQL Server using Entity Framework Core.  This project will utilize the shared Data project for access to the `IRepository<>` interface as well as the `Reservation` model class.

* Create new .NET Core Class Library project called `ReservationApi.Data.EFCore` to the solution and create the following folders

  * **Repos**

  * **DependencyInjection**

  * **Contexts**

* Add the following nuget references to project file

    ```xml
    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore" Version="2.2.6" />
        <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="2.2.6" />
        <PackageReference Include="Microsoft.Extensions.Configuration" Version="2.2.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="2.2.0" />
    </ItemGroup>

    ```

* Add a new class called `EFRepository` to the Repos folder and add the following implementation

    ```cs
    using Microsoft.EntityFrameworkCore;
    using ReservationApi.Data.Intefaces;
    using ReservationApi.Data.Models;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    namespace ReservationApi.Data.EFCore.Repos
    {
        public class EFRepository<T> : IRepository<T> where T : BaseEntity
        {
            protected readonly DbContext _context;
            protected DbSet<T> _entities;

            public EFRepository(DbContext context)
            {
                _context = context;
                _entities = context.Set<T>();
            }

            public async Task DeleteAsync(T entity)
            {
                _context.Remove<T>(entity);
                await _context.SaveChangesAsync();
            }

            public async Task DeleteAsync(string id)
            {
                var entityToDelete = await _entities.FindAsync(id);
                _context.Remove<T>(entityToDelete);
                await _context.SaveChangesAsync();
            }

            public async Task<T> GetAsync(string id)
            {
                return await _entities.FindAsync(id);
            }

            public async Task<List<T>> GetAsync()
            {
                return await _entities.ToListAsync();
            }

            public async Task<T> InsertAsync(T entity)
            {
                if (entity == null)
                    throw new ArgumentNullException(nameof(entity), "entity cannot be null");

                entity.Id = Guid.NewGuid().ToString();

                var newEntity = await _entities.AddAsync(entity);
                await _context.SaveChangesAsync();
                return newEntity.Entity;
            }

            public async Task UpdateAsync(T entity)
            {
                var entityToEdit = _entities.Find(entity.Id);

                if (entityToEdit == null)
                    throw new ArgumentException($"Couldn't find matching {nameof(T)} with Id={entity.Id}");

                _context.Entry(entityToEdit).CurrentValues.SetValues(entity);
                await _context.SaveChangesAsync();
            }
        }
    }
    ```

    >**NOTE**: This is the EF Core implementation of the IRepository<> interface

* Add a new class called `ReservationContext` within the Contexts folder and add the following implementation

    ```cs
    using Microsoft.EntityFrameworkCore;
    using ReservationApi.Data.Models;

    namespace ReservationApi.Data.EFCore.Contexts
    {
        public class ReservationContext : DbContext
        {
            public ReservationContext(DbContextOptions<ReservationContext> options) : base(options) { }

            public DbSet<Reservation> Products { get; set; }

            protected override void OnModelCreating(ModelBuilder modelBuilder)
            {
            }
        }
    }
    ```

* Add a new class called `ServiceCollectionExtensions` to the DependencyInjection folder and add the following implementation

    ```cs
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Configuration;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.DependencyInjection.Extensions;
    using ReservationApi.Data.EFCore.Contexts;
    using ReservationApi.Data.EFCore.Repos;
    using ReservationApi.Data.Intefaces;
    using ReservationApi.Data.Models;

    namespace ReservationApi.Data.EFCore.DependencyInjection
    {
        public static class ServiceCollectionExtensions
        {
            public static void AddSqlDatabaseSupport(this IServiceCollection services, IConfiguration configuration)
            {
                services.AddDbContext<ReservationContext>(options =>
                    options.UseSqlServer(configuration.GetConnectionString("DefaultConnection")));

                services.TryAddScoped<DbContext, ReservationContext>();
                services.TryAddScoped<IRepository<Reservation>, EFRepository<Reservation>>();
            }
        }
    }
    ```

    >**NOTE**: This is the extension method for registering SQL Server provider for EF Core within the `ReservationApi` webapi project.

* Use the following commands to create the SQL Server database using LocalDb

  * `Add-Migration 'initial' -project ReservationApi.Data.EFCore`
  
    This command will create a new folder within the `ReservationApi.Data.EFCore` project called **migrations** and will create some auto generated migration classes for scaffolding the database

  * `Update-Database`

    This command wll run the 'initial' migration that was just created and create the SQL Server database using the configured connection string within the `ReservationApi` webapi project.

* Add the SQL Server connection string to the WebApi project's `appsetting.development.json` file using the following config

    ```js
    "ConnectionStrings": {
        "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=ReservationDb;Trusted_Connection=True;MultipleActiveResultSets=true"
    }
    ``` 

    >**NOTE**: This connection string points to the LocalDb instance on the local computer and uses interactive user
